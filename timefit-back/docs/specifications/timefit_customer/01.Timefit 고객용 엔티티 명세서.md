# 01. Timefit 고객용 엔티티 명세서

## 📋 문서 정보
- **대상**: 고객용 API 개발
- **범위**: 신규 엔티티 + 기존 엔티티 확장

---

## 🎯 설계 원칙

### 1. 스냅샷 전략 (Snapshot Strategy)

고객 예약 데이터는 업체 정보 변경과 무관하게 **예약 당시 상태를 보존**해야 합니다.

#### Rule 1: 금전 관련은 무조건 스냅샷
```
필수 스냅샷 대상:
- 가격 (price)
- 결제 금액 (amount)
- 할인율/금액 (discount)

근거: 정산, 환불, 분쟁 시 증거 자료
```

#### Rule 2: 고객 연락처는 스냅샷
```
필수 스냅샷 대상:
- 고객명 (customerName)
- 전화번호 (customerPhone)

근거:
- 예약 당시 연락처 보존
- User 정보 변경 시에도 예약 SMS 발송 가능
```

#### Rule 3: 변경 가능한 메타데이터는 스냅샷
```
필수 스냅샷 대상:
- 서비스 소요시간 (durationMinutes)
- 서비스명 (menuName)

근거: 업체가 메뉴 수정/삭제해도 예약 히스토리 유지
```

#### Rule 4: 불변 데이터는 FK 참조
```
스냅샷 불필요:
- businessId, menuId, userId (FK)

근거: ID는 변하지 않으며, JOIN으로 최신 정보 조회 가능
```

---

### 2. 삭제 전략

#### Soft Delete (논리 삭제)
```
적용 대상:
- Review (리뷰) - 삭제되어도 평점 통계에 영향
- Reservation (예약) - 히스토리 유지 필요

구현: deletedAt (timestamp) 필드 추가
```

#### Cascade Delete (연쇄 삭제)
```
적용 대상:
- Wishlist (찜) - Menu 삭제 시 함께 삭제

구현: @OnDelete(action = OnDeleteAction.CASCADE)
```

---

## 📊 신규 엔티티

### 1. Wishlist (찜)

#### 목적
고객이 관심 있는 메뉴를 저장

#### 테이블 구조

| 컬럼명 | 타입 | Nullable | 제약 | 설명 |
|--------|------|----------|------|------|
| wishlist_id | UUID | NO | PK | 찜 ID |
| user_id | UUID | NO | FK (User) | 고객 ID |
| menu_id | UUID | NO | FK (Menu) | 메뉴 ID |
| created_at | TIMESTAMP | NO | - | 생성일시 |

#### 인덱스
```sql
PRIMARY KEY: wishlist_id
UNIQUE INDEX: (user_id, menu_id)  -- 중복 찜 방지
INDEX: (user_id, created_at DESC) -- 찜 목록 조회 최적화
```

#### 제약사항
- 1명의 고객은 동일 메뉴를 1번만 찜 가능
- Menu 삭제 시 Wishlist도 함께 삭제 (CASCADE)

#### 연관관계
```
User 1 : N Wishlist
Menu 1 : N Wishlist

Wishlist N : 1 User
Wishlist N : 1 Menu (CASCADE DELETE)
```

#### CASCADE 동작
- Menu 삭제 시 → 해당 Menu를 찜한 모든 Wishlist 자동 삭제
- User 삭제 시 → 해당 User의 모든 Wishlist 자동 삭제

---

### 2. Review (리뷰)

#### 목적
예약 완료 후 고객이 업체/서비스 평가

#### 테이블 구조

| 컬럼명 | 타입 | Nullable | 제약 | 설명 |
|--------|------|----------|------|------|
| review_id | UUID | NO | PK | 리뷰 ID |
| business_id | UUID | NO | FK (Business) | 업체 ID |
| user_id | UUID | NO | FK (User) | 작성자 ID |
| reservation_id | UUID | YES | FK (Reservation) | 예약 ID |
| menu_name | VARCHAR(100) | NO | - | 서비스명 (스냅샷) |
| rating | INTEGER | NO | 1 ≤ rating ≤ 5 | 평점 |
| comment | TEXT | YES | - | 리뷰 내용 |
| created_at | TIMESTAMP | NO | - | 작성일시 |
| updated_at | TIMESTAMP | NO | - | 수정일시 |
| deleted_at | TIMESTAMP | YES | - | 삭제일시 (Soft Delete) |

#### 인덱스
```sql
PRIMARY KEY: review_id
INDEX: (business_id, created_at DESC)     -- 업체별 최신 리뷰 조회
INDEX: (business_id, rating)              -- 평점별 필터링
UNIQUE INDEX: (reservation_id)            -- 1개 예약당 1개 리뷰
INDEX: (user_id, created_at DESC)         -- 내가 작성한 리뷰
INDEX: (deleted_at)                       -- Soft delete 조회 최적화
```

#### 제약사항
- 1개 예약당 1개 리뷰만 작성 가능 (reservation_id UNIQUE)
- 예약 완료 상태(COMPLETED)에서만 작성 가능 (애플리케이션 레벨)
- 삭제 시 Soft Delete (deleted_at 업데이트)

#### 스냅샷 필드
- `menu_name`: Menu 삭제되어도 리뷰에 "어떤 서비스였는지" 표시

#### 연관관계
```
Business 1 : N Review
User 1 : N Review
Reservation 1 : 0..1 Review (optional)

Review N : 1 Business
Review N : 1 User
Review N : 0..1 Reservation (optional)
```

#### Soft Delete 동작
- 리뷰 삭제 시 → `deleted_at`에 삭제 시각 기록
- 조회 시 `deleted_at IS NULL` 조건 필수
- 평점 통계 재계산 필요

---

### 3. 최근 검색어 (SearchHistory) - Phase 3 (선택)

#### 구현 방식
**브라우저 로컬 스토리지 사용 (DB 저장 X)**

#### 이유
- 고객 개인 데이터로 서버 저장 불필요
- 로컬 스토리지로 빠른 응답 가능
- 서버 부하 감소

#### 프론트엔드 구현
```
로컬 스토리지 키: 'search_history'
최대 보관: 10개
정렬: 최신순 (searched_at DESC)
```

#### 백엔드 API
**검색 API에서 자동 처리**
- 기존 `GET /api/business/search?keyword=...` 활용
- 프론트엔드가 검색 결과 받은 후 로컬 스토리지에 저장
- 별도 검색어 저장 API 불필요

---

## 🔄 기존 엔티티 확장

### 1. Business 엔티티

#### 추가 필드

| 필드명 | 타입 | Nullable | 기본값 | 설명 |
|--------|------|----------|--------|------|
| average_rating | DOUBLE | NO | 0.0 | 평균 평점 |
| review_count | INTEGER | NO | 0 | 리뷰 수 |
| latitude | DOUBLE | YES | null | 위도 (향후 지도 기능용) |
| longitude | DOUBLE | YES | null | 경도 (향후 지도 기능용) |

**참고**: `businessNotice` 필드는 이미 존재함 (고객용 공지사항)

#### 인덱스 추가
```sql
INDEX: (average_rating DESC)              -- 평점순 정렬
INDEX: (review_count DESC)                -- 인기순 정렬
INDEX: (latitude, longitude)              -- 위치 기반 검색 (PostGIS 적용 시)
```

#### 평점 갱신 전략
```
방법 1: 리뷰 생성/수정/삭제 시 즉시 갱신 (트랜잭션)
방법 2: 배치 작업 (매시간 또는 매일)

권장: 방법 1 (즉시 갱신)
- 리뷰 작성 빈도가 높지 않음
- 실시간 반영 필요
```

#### 갱신 로직
```
새 평균 평점 = SUM(rating) / COUNT(rating) WHERE deleted_at IS NULL
새 리뷰 수 = COUNT(*) WHERE deleted_at IS NULL
```

---

### 2. User 엔티티

#### 확인 사항
기존 User 엔티티에 필요한 필드가 모두 존재함:
- `profileImageUrl` - 프로필 이미지 URL ✅

**추가 필드 불필요**

---

## 📐 ERD 관계도

```
User (고객)
  ├─ 1:N → Reservation (예약)
  ├─ 1:N → Wishlist (찜)
  └─ 1:N → Review (리뷰)

Business (업체)
  ├─ 1:N → Menu (서비스)
  ├─ 1:N → BookingSlot (예약 슬롯)
  ├─ 1:N → Reservation (예약)
  ├─ 1:N → Review (리뷰)
  └─ 1:N → OperatingHours (영업시간)

Menu (서비스)
  ├─ 1:N → Reservation (예약)
  ├─ 1:N → Wishlist (찜)
  └─ 1:N → BookingSlot (예약 슬롯)

Reservation (예약)
  └─ 1:0..1 → Review (리뷰, optional)

Review (리뷰)
  ├─ N:1 → Business (업체)
  ├─ N:1 → User (작성자)
  └─ N:0..1 → Reservation (예약, optional)

Wishlist (찜)
  ├─ N:1 → User (고객)
  └─ N:1 → Menu (메뉴, CASCADE DELETE)
```

---

## 📝 개발 참고사항

### 엔티티 우선순위

**Phase 1 (P0)**: 필수
- Wishlist
- Review
- Business 확장 필드 (평점, 리뷰 수)

**Phase 2 (P1)**: 중요
- Business 위치 필드 (latitude, longitude)