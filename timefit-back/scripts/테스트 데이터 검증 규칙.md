# 테스트 데이터 검증 규칙

> **seed-bulk.sql 데이터의 무결성을 검증하는 규칙과 쿼리**

---

## 문서 목적

이 문서는 **개발자 및 AI 학습/참고용**으로 작성되었습니다.

**주요 용도:**
- 테스트 데이터의 무결성 검증
- 데이터 계층 구조 이해
- 디버깅 및 문제 해결
- AI 모델의 데이터 관계 학습

**일반 사용자는 README.md만 읽어도 충분합니다.**

---

## 데이터 계층 구조

```
Level 1: BusinessHours (전체 영업 시간 바운더리)
           ↓ 제약: OperatingHours ⊆ BusinessHours
Level 2: OperatingHours (예약 가능 시간대)
           ↓ 제약: BookingSlot ⊆ OperatingHours
Level 3: Menu (서비스, duration 정의)
           ↓ 생성: BookingSlot (Menu.duration 간격)
Level 4: BookingSlot (실제 예약 가능 슬롯)
           ↓ 제약: Reservation → valid BookingSlot
Level 5: Reservation (고객 예약)
```

---

## 필수 제약 조건

### 1. BusinessHours ⊇ OperatingHours
```
모든 OperatingHours는 해당 요일의 BusinessHours 내에 있어야 함

예시:
  BusinessHours (월): 09:00-18:00
  OperatingHours (월): 09:00-12:00 (seq 0), 13:00-18:00 (seq 1) ✓
  OperatingHours (월): 08:00-19:00 ✗ (바운더리 초과!)
```

**검증 쿼리:**
```sql
-- 바운더리 위반 확인 (0개여야 정상)
SELECT 
    oh.business_id,
    oh.day_of_week,
    oh.open_time as oh_open,
    oh.close_time as oh_close,
    bh.open_time as bh_open,
    bh.close_time as bh_close
FROM operating_hours oh
JOIN business_hours bh 
    ON oh.business_id = bh.business_id 
    AND oh.day_of_week = bh.day_of_week
WHERE oh.open_time < bh.open_time 
   OR oh.close_time > bh.close_time;

-- Expected: 0 rows
```

---

### 2. OperatingHours sequence로 브레이크타임 표현
```
같은 day_of_week에 여러 sequence가 있으면 그 사이는 브레이크타임

예시 (Hair Salon 평일):
  sequence=0: 09:00-12:00
  sequence=1: 13:00-18:00
  → 12:00-13:00은 브레이크타임 (점심시간, 예약 불가)
```

**검증 쿼리:**
```sql
-- Business 1 평일의 브레이크타임 확인
SELECT 
    day_of_week,
    sequence,
    open_time,
    close_time
FROM operating_hours
WHERE business_id = '30000000-0000-0000-0000-000000000001'
  AND day_of_week BETWEEN 0 AND 4
ORDER BY day_of_week, sequence;

-- Expected:
-- day_of_week=0, seq=0: 09:00-12:00
-- day_of_week=0, seq=1: 13:00-18:00
-- (12:00-13:00 gap = 브레이크타임)
```

---

### 3. BookingSlot은 OperatingHours 시간대 내에만
```
BookingSlot은 해당 요일의 OperatingHours 범위를 벗어날 수 없음
브레이크타임에는 슬롯이 생성되지 않아야 함

예시:
  OperatingHours (월): 09:00-12:00, 13:00-18:00
  BookingSlot: 09:00, 10:00, 11:00, 13:00, 14:00, ... ✓
  BookingSlot: 12:00, 12:30 ✗ (브레이크타임!)
```

**검증 쿼리:**
```sql
-- 브레이크타임(12:00-13:00)에 슬롯이 없는지 확인
SELECT COUNT(*) as invalid_slots
FROM booking_slot
WHERE business_id = '30000000-0000-0000-0000-000000000001'
  AND start_time >= '12:00:00'
  AND start_time < '13:00:00'
  AND EXTRACT(ISODOW FROM slot_date) BETWEEN 1 AND 5;

-- Expected: 0
```

---

### 4. BookingSlot duration = Menu duration
```
BookingSlot의 end_time - start_time = Menu.duration_minutes

예시:
  Menu (Shampoo): duration_minutes = 30
  BookingSlot: 09:00-09:30 ✓
  BookingSlot: 09:00-10:00 ✗ (60분!)
```

**검증 쿼리:**
```sql
-- duration 불일치 확인 (0개여야 정상)
SELECT 
    bs.id,
    m.service_name,
    m.duration_minutes as menu_duration,
    EXTRACT(EPOCH FROM (bs.end_time - bs.start_time))/60 as slot_duration
FROM booking_slot bs
JOIN menu m ON bs.menu_id = m.id
WHERE EXTRACT(EPOCH FROM (bs.end_time - bs.start_time))/60 != m.duration_minutes;

-- Expected: 0 rows
```

---

### 5. Reservation은 유효한 BookingSlot만 참조
```
모든 Reservation.booking_slot_id는 실제 존재하는 BookingSlot이어야 함
```

**검증 쿼리:**
```sql
-- 유효하지 않은 예약 확인 (0개여야 정상)
SELECT COUNT(*) as invalid_reservations
FROM reservation r
WHERE r.booking_slot_id NOT IN (
    SELECT id FROM booking_slot
);

-- Expected: 0
```

---

## 데이터 규모 검증

### 전체 개수 확인
```sql
SELECT 
    'business_hours' as table_name, 
    COUNT(*) as count,
    21 as expected,
    CASE WHEN COUNT(*) = 21 THEN '✓' ELSE '✗' END as status
FROM business_hours
UNION ALL
SELECT 
    'operating_hours', 
    COUNT(*),
    31,
    CASE WHEN COUNT(*) = 31 THEN '✓' ELSE '✗' END
FROM operating_hours
UNION ALL
SELECT 
    'booking_slot',
    COUNT(*),
    3000,
    CASE WHEN COUNT(*) BETWEEN 2800 AND 3200 THEN '✓' ELSE '✗' END
FROM booking_slot
UNION ALL
SELECT 
    'reservation',
    COUNT(*),
    10000,
    CASE WHEN COUNT(*) = 10000 THEN '✓' ELSE '✗' END
FROM reservation;
```

### 업체별 슬롯 분포
```sql
-- 각 업체의 슬롯 개수
SELECT 
    b.business_name,
    COUNT(bs.id) as slot_count
FROM business b
LEFT JOIN booking_slot bs ON b.id = bs.business_id
GROUP BY b.id, b.business_name
ORDER BY b.id;

-- Expected:
-- Hair Salon: ~2,160
-- Nail Shop: ~850
-- Cafe: 0 (ONDEMAND)
```

---

## 핵심 검증 시나리오

### 시나리오 1: 점심시간 검증
```sql
-- Hair Salon 평일 12:00-13:00에 슬롯이 없는가?
SELECT 
    slot_date,
    start_time,
    end_time
FROM booking_slot
WHERE business_id = '30000000-0000-0000-0000-000000000001'
  AND EXTRACT(ISODOW FROM slot_date) BETWEEN 1 AND 5
  AND start_time >= '12:00:00'
  AND start_time < '13:00:00';

-- Expected: 0 rows ✓
```

### 시나리오 2: duration 정확성 검증
```sql
-- Shampoo (30분) 슬롯이 정확히 30분 간격인가?
SELECT 
    slot_date,
    start_time,
    end_time,
    EXTRACT(EPOCH FROM (end_time - start_time))/60 as duration_min
FROM booking_slot
WHERE menu_id = '60000000-0000-0000-0000-000000000009'
  AND slot_date = CURRENT_DATE
LIMIT 10;

-- Expected: 모두 30.0
```

### 시나리오 3: sequence 순서 검증
```sql
-- OperatingHours가 sequence 순서대로 정렬되는가?
SELECT 
    day_of_week,
    sequence,
    open_time,
    close_time
FROM operating_hours
WHERE business_id = '30000000-0000-0000-0000-000000000001'
  AND day_of_week = 0
ORDER BY sequence;

-- Expected:
-- seq 0: 09:00-12:00
-- seq 1: 13:00-18:00
```

### 시나리오 4: 주말 단축 영업 검증
```sql
-- Hair Salon 주말이 09:00-14:00인가?
SELECT 
    day_of_week,
    open_time,
    close_time
FROM business_hours
WHERE business_id = '30000000-0000-0000-0000-000000000001'
  AND day_of_week IN (5, 6);

-- Expected:
-- 토: 09:00-14:00
-- 일: 09:00-14:00
```

---

## 문제 해결 가이드

### 문제: OperatingHours가 31개가 아님
```bash
# 해결: 데이터 재생성
# Windows
.\scripts\clear-test-data.ps1
.\scripts\init-test-data.ps1

# macOS/Linux
./scripts/clear-test-data.sh
./scripts/init-test-data.sh
```

### 문제: 브레이크타임에 슬롯이 있음
```sql
-- 원인 파악
SELECT * FROM booking_slot
WHERE business_id = '30000000-0000-0000-0000-000000000001'
  AND start_time BETWEEN '12:00' AND '13:00'
  AND EXTRACT(ISODOW FROM slot_date) BETWEEN 1 AND 5;

-- 해결: SQL 재확인 후 재생성
```

### 문제: duration 불일치
```sql
-- 어떤 메뉴가 문제인지 확인
SELECT 
    m.service_name,
    m.duration_minutes,
    COUNT(bs.id) as slot_count,
    AVG(EXTRACT(EPOCH FROM (bs.end_time - bs.start_time))/60) as avg_duration
FROM booking_slot bs
JOIN menu m ON bs.menu_id = m.id
GROUP BY m.id, m.service_name, m.duration_minutes
HAVING AVG(EXTRACT(EPOCH FROM (bs.end_time - bs.start_time))/60) != m.duration_minutes;

-- 해결: 해당 메뉴의 BookingSlot 생성 로직 수정
```

---

## 완전 검증 스크립트

```sql
-- 모든 제약 조건 한번에 검증
DO $$
DECLARE
    v_count INTEGER;
    v_errors TEXT := '';
BEGIN
    -- 1. BusinessHours ⊇ OperatingHours
    SELECT COUNT(*) INTO v_count
    FROM operating_hours oh
    JOIN business_hours bh ON oh.business_id = bh.business_id 
        AND oh.day_of_week = bh.day_of_week
    WHERE oh.open_time < bh.open_time OR oh.close_time > bh.close_time;
    
    IF v_count > 0 THEN
        v_errors := v_errors || '✗ BusinessHours 바운더리 위반: ' || v_count || E'\n';
    END IF;
    
    -- 2. 브레이크타임에 슬롯 없음
    SELECT COUNT(*) INTO v_count
    FROM booking_slot
    WHERE business_id = '30000000-0000-0000-0000-000000000001'
      AND start_time >= '12:00:00' AND start_time < '13:00:00'
      AND EXTRACT(ISODOW FROM slot_date) BETWEEN 1 AND 5;
    
    IF v_count > 0 THEN
        v_errors := v_errors || '✗ 브레이크타임에 슬롯 존재: ' || v_count || E'\n';
    END IF;
    
    -- 3. Duration 일치
    SELECT COUNT(*) INTO v_count
    FROM booking_slot bs
    JOIN menu m ON bs.menu_id = m.id
    WHERE EXTRACT(EPOCH FROM (bs.end_time - bs.start_time))/60 != m.duration_minutes;
    
    IF v_count > 0 THEN
        v_errors := v_errors || '✗ Duration 불일치: ' || v_count || E'\n';
    END IF;
    
    -- 4. 유효한 BookingSlot 참조
    SELECT COUNT(*) INTO v_count
    FROM reservation r
    WHERE r.booking_slot_id NOT IN (SELECT id FROM booking_slot);
    
    IF v_count > 0 THEN
        v_errors := v_errors || '✗ 유효하지 않은 Reservation: ' || v_count || E'\n';
    END IF;
    
    -- 결과 출력
    IF v_errors = '' THEN
        RAISE NOTICE '✓ 모든 검증 통과!';
    ELSE
        RAISE EXCEPTION E'검증 실패:\n%', v_errors;
    END IF;
END $$;
```

---

## 요약

### 5가지 핵심 제약 조건
1. BusinessHours ⊇ OperatingHours
2. sequence로 브레이크타임 표현
3. BookingSlot은 OperatingHours 내에만
4. BookingSlot duration = Menu duration
5. Reservation → valid BookingSlot

### 검증 순서
```bash
# 1. 데이터 생성
# Windows: .\scripts\init-test-data.ps1
# macOS/Linux: ./scripts/init-test-data.sh

# 2. 개수 확인
psql -U timefit_admin -d timefit_db -c "
  SELECT 'operating_hours', COUNT(*) FROM operating_hours;
  -- Expected: 31
"

# 3. 제약 조건 검증 (위의 SQL 실행)

# 4. 문제 발견 시 재생성
# Windows: .\scripts\clear-test-data.ps1 && .\scripts\init-test-data.ps1
# macOS/Linux: ./scripts/clear-test-data.sh && ./scripts/init-test-data.sh
```